import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../directives/tree-drop.directive';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Component, Input, ViewEncapsulation } from '@angular/core';
import { TreeNode } from '../models/tree-node.model';
var TreeNodeDropSlot = /** @class */ (function () {
    function TreeNodeDropSlot() {
    }
    TreeNodeDropSlot.prototype.onDrop = function ($event) {
        this.node.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this.node, index: this.dropIndex }
        });
    };
    TreeNodeDropSlot.prototype.allowDrop = function (element, $event) {
        return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);
    };
    __decorate([
        Input(),
        __metadata("design:type", TreeNode)
    ], TreeNodeDropSlot.prototype, "node", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TreeNodeDropSlot.prototype, "dropIndex", void 0);
TreeNodeDropSlot.ɵfac = function TreeNodeDropSlot_Factory(t) { return new (t || TreeNodeDropSlot)(); };
TreeNodeDropSlot.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeNodeDropSlot, selectors: [["TreeNodeDropSlot"], ["tree-node-drop-slot"]], inputs: { node: "node", dropIndex: "dropIndex" }, decls: 1, vars: 2, consts: [[1, "node-drop-slot", 3, "treeAllowDrop", "allowDragoverStyling", "treeDrop"]], template: function TreeNodeDropSlot_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("treeDrop", function TreeNodeDropSlot_Template_div_treeDrop_0_listener($event) { return ctx.onDrop($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("treeAllowDrop", ctx.allowDrop.bind(ctx))("allowDragoverStyling", true);
    } }, directives: [ɵngcc1.TreeDropDirective], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeNodeDropSlot, [{
        type: Component,
        args: [{
                selector: 'TreeNodeDropSlot, tree-node-drop-slot',
                encapsulation: ViewEncapsulation.None,
                styles: [],
                template: "\n    <div\n      class=\"node-drop-slot\"\n      (treeDrop)=\"onDrop($event)\"\n      [treeAllowDrop]=\"allowDrop.bind(this)\"\n      [allowDragoverStyling]=\"true\">\n    </div>\n  "
            }]
    }], function () { return []; }, { node: [{
            type: Input
        }], dropIndex: [{
            type: Input
        }] }); })();
    return TreeNodeDropSlot;
}());
export { TreeNodeDropSlot };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLWRyb3Atc2xvdC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jb21wb25lbnRzL3RyZWUtbm9kZS1kcm9wLXNsb3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBZXJEO0FBQ29CLElBRHBCO0FBQThCLElBYzlCLENBQUM7QUFDRCxJQVhFLGlDQUFNLEdBQU4sVUFBTyxNQUFNO0FBQ2YsUUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRTtBQUNoRCxZQUFNLElBQUksRUFBRSxNQUFNLENBQUMsT0FBTztBQUMxQixZQUFNLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ3RELFNBQUssQ0FBQyxDQUFDO0FBQ1AsSUFBRSxDQUFDO0FBRUgsSUFBRSxvQ0FBUyxHQUFULFVBQVUsT0FBTyxFQUFFLE1BQU07QUFDM0IsUUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3RHLElBQUUsQ0FBQztBQUNGLElBYlU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBRSxrQ0FBSyxRQUFRO0FBQ3pCLGtEQUQwQjtBQUN6QixJQUFVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUU7QUFHUix1REFIeUI7SUFGaEIsZ0JBQWdCLHdCQWI1QixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUU7YUFBdUMsY0FDakQsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUksY0FDckMsTUFBTSxFQUFFLEVBQUUsY0FDVixRQUFRLEVBQUUseUxBT1QsVUFDRixDQUFDLFFBQ1csZ0JBQWdCLENBYzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCx1QkFBQztBQUNBLENBREEsQUFkRCxJQWNDO0FBQ0QsU0FmYSxnQkFBZ0I7QUFDNUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJlZU5vZGUgfSBmcm9tICcuLi9tb2RlbHMvdHJlZS1ub2RlLm1vZGVsJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnVHJlZU5vZGVEcm9wU2xvdCwgdHJlZS1ub2RlLWRyb3Atc2xvdCcsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIHN0eWxlczogW10sXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdlxuICAgICAgY2xhc3M9XCJub2RlLWRyb3Atc2xvdFwiXG4gICAgICAodHJlZURyb3ApPVwib25Ecm9wKCRldmVudClcIlxuICAgICAgW3RyZWVBbGxvd0Ryb3BdPVwiYWxsb3dEcm9wLmJpbmQodGhpcylcIlxuICAgICAgW2FsbG93RHJhZ292ZXJTdHlsaW5nXT1cInRydWVcIj5cbiAgICA8L2Rpdj5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBUcmVlTm9kZURyb3BTbG90IHtcbiAgQElucHV0KCkgbm9kZTogVHJlZU5vZGU7XG4gIEBJbnB1dCgpIGRyb3BJbmRleDogbnVtYmVyO1xuXG4gIG9uRHJvcCgkZXZlbnQpIHtcbiAgICB0aGlzLm5vZGUubW91c2VBY3Rpb24oJ2Ryb3AnLCAkZXZlbnQuZXZlbnQsIHtcbiAgICAgIGZyb206ICRldmVudC5lbGVtZW50LFxuICAgICAgdG86IHsgcGFyZW50OiB0aGlzLm5vZGUsIGluZGV4OiB0aGlzLmRyb3BJbmRleCB9XG4gICAgfSk7XG4gIH1cblxuICBhbGxvd0Ryb3AoZWxlbWVudCwgJGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5vcHRpb25zLmFsbG93RHJvcChlbGVtZW50LCB7IHBhcmVudDogdGhpcy5ub2RlLCBpbmRleDogdGhpcy5kcm9wSW5kZXggfSwgJGV2ZW50KTtcbiAgfVxufVxuIl19